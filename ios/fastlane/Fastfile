# ios/fastlane/Fastfile - Updated with auto version management
default_platform(:ios)

platform :ios do
  
  before_all do
    setup_circle_ci if ENV['CI']
    ensure_bundle_exec
    auto_update_version if ENV['GITHUB_RUN_NUMBER']
  end

  # ‚ú® ‡πÄ‡∏û‡∏¥‡πà‡∏°: Auto version management
  private_lane :auto_update_version do
    begin
      # ‡∏î‡∏∂‡∏á version ‡∏à‡∏≤‡∏Å package.json
      package_json_path = File.expand_path('../../package.json')
      if File.exist?(package_json_path)
        package_json = JSON.parse(File.read(package_json_path))
        new_version = package_json['version']
      else
        UI.error("package.json not found, using default version")
        new_version = "1.0.0"
      end
      
      # ‡πÉ‡∏ä‡πâ GitHub run number ‡πÄ‡∏õ‡πá‡∏ô build number
      build_number = ENV['GITHUB_RUN_NUMBER'] || "1"
      branch = ENV['GITHUB_REF_NAME'] || 'develop'
      
      # ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó iOS version
      increment_version_number(
        version_number: new_version,
        xcodeproj: "TestCICD.xcodeproj"
      )
      
      increment_build_number(
        build_number: build_number,
        xcodeproj: "TestCICD.xcodeproj"
      )
      
      UI.success("‚úÖ Auto updated iOS version:")
      UI.success("   CFBundleShortVersionString: #{new_version}")
      UI.success("   CFBundleVersion: #{build_number}")
      UI.success("   branch: #{branch}")
      
    rescue => e
      UI.error("‚ùå Failed to auto update version: #{e.message}")
      UI.error("Continuing with existing version...")
    end
  end

  # ‚ú® ‡πÄ‡∏û‡∏¥‡πà‡∏°: Manual version management
  lane :set_version do |options|
    version = options[:version] || prompt(text: "Enter version (e.g., 1.2.3):")
    build = options[:build] || prompt(text: "Enter build number (e.g., 123):")
    
    increment_version_number(
      version_number: version,
      xcodeproj: "TestCICD.xcodeproj"
    )
    
    increment_build_number(
      build_number: build,
      xcodeproj: "TestCICD.xcodeproj"
    )
    
    UI.success("‚úÖ Manually set iOS version:")
    UI.success("   CFBundleShortVersionString: #{version}")
    UI.success("   CFBundleVersion: #{build}")
  end

  lane :bump_version do |options|
    type = options[:type] || "patch"
    
    # ‡∏≠‡πà‡∏≤‡∏ô version ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
    current_version = get_version_number(xcodeproj: "TestCICD.xcodeproj")
    current_build = get_build_number(xcodeproj: "TestCICD.xcodeproj").to_i
    
    # Parse semantic version
    version_parts = current_version.split('.').map(&:to_i)
    
    case type
    when "major"
      version_parts[0] += 1
      version_parts[1] = 0
      version_parts[2] = 0
    when "minor"
      version_parts[1] += 1
      version_parts[2] = 0
    when "patch"
      version_parts[2] += 1
    end
    
    new_version = version_parts.join('.')
    new_build = current_build + 1
    
    increment_version_number(
      version_number: new_version,
      xcodeproj: "TestCICD.xcodeproj"
    )
    
    increment_build_number(
      build_number: new_build.to_s,
      xcodeproj: "TestCICD.xcodeproj"
    )
    
    UI.success("‚úÖ Bumped #{type} version:")
    UI.success("   #{current_version} -> #{new_version}")
    UI.success("   build: #{current_build} -> #{new_build}")
  end

  # üöÄ Deployment lanes (‡πÄ‡∏î‡∏¥‡∏° + ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á)
  lane :deploy_develop do
    UI.message("üöÄ Deploying to TestFlight Internal...")
    build_and_deploy(
      groups: ["Internal Testers", "Developers"],
      skip_waiting: true
    )
    notify_slack("üöÄ iOS Development build uploaded to TestFlight Internal!")
  end

  lane :deploy_preprod do
    UI.message("üöÄ Deploying to TestFlight Beta...")
    build_and_deploy(
      groups: ["Beta Testers", "QA Team"],
      skip_waiting: false
    )
    notify_slack("üöÄ iOS Pre-production build uploaded to TestFlight Beta!")
  end

  lane :deploy_master do
    UI.message("üéâ Deploying to App Store...")
    setup_certificates
    build_release_app
    
    upload_to_app_store(
      api_key_path: ENV['APP_STORE_CONNECT_API_KEY_PATH'],
      force: true,
      submit_for_review: false,  # ‡πÅ‡∏¢‡∏Å submit ‡∏≠‡∏≠‡∏Å‡∏°‡∏≤
      automatic_release: false,
      skip_metadata: true,
      skip_screenshots: true,
      precheck_include_in_app_purchases: false
    )
    
    notify_slack("üéâ iOS Production build uploaded to App Store Connect!")
  end

  lane :build_only do
    UI.message("üî® Building iOS app...")
    setup_certificates
    build_release_app
    UI.success("‚úÖ iOS build completed successfully!")
  end

  lane :submit_for_review do
    UI.message("üìã Submitting for App Store review...")
    upload_to_app_store(
      api_key_path: ENV['APP_STORE_CONNECT_API_KEY_PATH'],
      skip_binary_upload: true,
      submit_for_review: true,
      automatic_release: false,
      force: true,
      submission_information: submission_info
    )
    notify_slack("üìã iOS app submitted for App Store review!")
  end

  # ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡πà‡∏ô - ‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á‡πÅ‡∏•‡∏∞‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô
  private_lane :setup_certificates do
    begin
      # ‡πÄ‡∏û‡∏¥‡πà‡∏° require ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Base64 (‡∏ö‡∏≤‡∏á environment ‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏°‡∏µ)
      require 'base64'
      
      api_key_path = nil
      
      # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ API key ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      if ENV['APP_STORE_CONNECT_API_KEY_BASE64'] && !ENV['APP_STORE_CONNECT_API_KEY_BASE64'].empty?
        UI.message("üîë Found base64 encoded API key")
        
        # Method 1: Decode base64
        begin
          api_key_content = Base64.decode64(ENV['APP_STORE_CONNECT_API_KEY_BASE64'])
          api_key_path = '/tmp/AuthKey.p8'
          File.write(api_key_path, api_key_content)
          
          # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏Ç‡∏ô‡∏≤‡∏î‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 0
          unless File.exist?(api_key_path) && File.size(api_key_path) > 0
            raise "Failed to create API key file"
          end
          
          UI.success("‚úÖ API key file created successfully")
          
        rescue => decode_error
          UI.error("‚ùå Failed to decode base64 API key: #{decode_error.message}")
          api_key_path = nil
        end
        
      elsif ENV['APP_STORE_CONNECT_API_KEY_CONTENT'] && !ENV['APP_STORE_CONNECT_API_KEY_CONTENT'].empty?
        UI.message("üîë Found raw API key content")
        
        # Method 2: Direct content
        begin
          api_key_path = '/tmp/AuthKey.p8'
          File.write(api_key_path, ENV['APP_STORE_CONNECT_API_KEY_CONTENT'])
          
          unless File.exist?(api_key_path) && File.size(api_key_path) > 0
            raise "Failed to create API key file"
          end
          
          UI.success("‚úÖ API key file created successfully")
          
        rescue => write_error
          UI.error("‚ùå Failed to write API key content: #{write_error.message}")
          api_key_path = nil
        end
        
      elsif ENV['APP_STORE_CONNECT_API_KEY_PATH'] && File.exist?(ENV['APP_STORE_CONNECT_API_KEY_PATH'])
        UI.message("üîë Found existing API key path")
        api_key_path = ENV['APP_STORE_CONNECT_API_KEY_PATH']
        
      else
        UI.message("‚ö†Ô∏è No API key found in environment variables")
        UI.message("Available options:")
        UI.message("- APP_STORE_CONNECT_API_KEY_BASE64 (base64 encoded .p8 file)")
        UI.message("- APP_STORE_CONNECT_API_KEY_CONTENT (raw .p8 content)")  
        UI.message("- APP_STORE_CONNECT_API_KEY_PATH (path to .p8 file)")
      end
      
      # ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ API key ‡πÉ‡∏´‡πâ setup
      if api_key_path
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö required environment variables
        unless ENV['APP_STORE_CONNECT_API_KEY_ID'] && ENV['APP_STORE_CONNECT_API_ISSUER_ID']
          raise "‚ùå Missing required environment variables: APP_STORE_CONNECT_API_KEY_ID or APP_STORE_CONNECT_API_ISSUER_ID"
        end
        
        # Setup API key
        app_store_connect_api_key(
          key_id: ENV['APP_STORE_CONNECT_API_KEY_ID'],
          issuer_id: ENV['APP_STORE_CONNECT_API_ISSUER_ID'],
          key_filepath: api_key_path
        )
        
        UI.success("‚úÖ App Store Connect API key configured successfully")
        
        # Setup certificates with API key
        match(
          type: "appstore",
          readonly: true,
          api_key_path: api_key_path
        )
        
      else
        UI.message("üîê Falling back to match without API key")
        
        # Fallback: ‡πÉ‡∏ä‡πâ match ‡πÅ‡∏ö‡∏ö‡∏õ‡∏Å‡∏ï‡∏¥
        match(
          type: "appstore", 
          readonly: true
        )
      end
      
      UI.success("‚úÖ Certificate setup completed successfully")
      
    rescue => e
      UI.error("‚ùå Certificate setup failed: #{e.message}")
      UI.error("Stack trace: #{e.backtrace.first(3).join("\n")}")
      
      # ‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡πÑ‡∏ü‡∏•‡πå API key ‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ß‡πâ
      begin
        File.delete('/tmp/AuthKey.p8') if File.exist?('/tmp/AuthKey.p8')
      rescue
        # ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£
      end
      
      # Re-raise error ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ build ‡∏´‡∏¢‡∏∏‡∏î
      raise e
    ensure
      # ‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡πÑ‡∏ü‡∏•‡πå API key ‡∏´‡∏•‡∏±‡∏á‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÄ‡∏™‡∏£‡πá‡∏à (security)
      begin
        File.delete('/tmp/AuthKey.p8') if File.exist?('/tmp/AuthKey.p8')
        UI.message("üßπ Cleaned up temporary API key file")
      rescue
        # ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£
      end
    end
  end

  private_lane :build_release_app do
    build_app(
      scheme: "TestCICD",
      workspace: "TestCICD.xcworkspace",
      configuration: "Release",
      export_method: "app-store",
      clean: true,
      output_directory: "./build",
      output_name: "TestCICD.ipa",
      include_bitcode: false,
      export_options: {
        provisioningProfiles: {
          "test.cicd.appibc" => "match AppStore test.cicd.appibc"
        }
      }
    )
  end

  private_lane :build_and_deploy do |options|
    setup_certificates
    build_release_app
    
    upload_to_testflight(
      api_key_path: ENV['APP_STORE_CONNECT_API_KEY_PATH'],
      skip_waiting_for_build_processing: options[:skip_waiting],
      groups: options[:groups],
      distribute_external: false,
      notify_external_testers: false,
      changelog: "Automated build from #{ENV['GITHUB_REF_NAME']} branch"
    )
  end

  private_lane :submission_info do
    {
      add_id_info_limits_tracking: true,
      add_id_info_serves_ads: false,
      add_id_info_tracks_action: true,
      add_id_info_tracks_install: true,
      add_id_info_uses_idfa: true,
      content_rights_has_rights: true,
      content_rights_contains_third_party_content: true,
      export_compliance_platform: 'ios',
      export_compliance_compliance_required: false,
      export_compliance_encryption_updated: false,
      export_compliance_uses_encryption: false,
      export_compliance_is_exempt: false,
      export_compliance_contains_third_party_cryptography: false,
      export_compliance_contains_proprietary_cryptography: false,
      export_compliance_available_on_french_store: false
    }
  end

  private_lane :notify_slack do |message|
    return unless ENV["SLACK_URL"]
    
    begin
      slack(
        message: message,
        channel: "#releases",
        webhook_url: ENV["SLACK_URL"],
        username: "iOS CI/CD",
        icon_emoji: ":apple:"
      )
    rescue => e
      UI.error("Failed to send Slack notification: #{e.message}")
    end
  end

  # Error handling
  error do |lane, exception|
    error_message = "‚ùå iOS deployment failed in lane '#{lane}': #{exception.message}"
    UI.error(error_message)
    notify_slack(error_message) if defined?(notify_slack)
    raise exception
  end
end