# ios/fastlane/Fastfile - Fixed version with better error handling
default_platform(:ios)

platform :ios do
  
  before_all do
    setup_circle_ci if ENV['CI']
    ensure_bundle_exec
    auto_update_version if ENV['GITHUB_RUN_NUMBER']
  end

  # âœ¨ Auto version management
  private_lane :auto_update_version do
    begin
      package_json_path = File.expand_path('../../package.json')
      if File.exist?(package_json_path)
        package_json = JSON.parse(File.read(package_json_path))
        new_version = package_json['version']
      else
        UI.error("package.json not found, using default version")
        new_version = "1.0.0"
      end
      
      build_number = ENV['GITHUB_RUN_NUMBER'] || "1"
      branch = ENV['GITHUB_REF_NAME'] || 'develop'
      
      increment_version_number(
        version_number: new_version,
        xcodeproj: "TestCICD.xcodeproj"
      )
      
      increment_build_number(
        build_number: build_number,
        xcodeproj: "TestCICD.xcodeproj"
      )
      
      UI.success("âœ… Auto updated iOS version:")
      UI.success("   CFBundleShortVersionString: #{new_version}")
      UI.success("   CFBundleVersion: #{build_number}")
      UI.success("   branch: #{branch}")
      
    rescue => e
      UI.error("âŒ Failed to auto update version: #{e.message}")
      UI.error("Continuing with existing version...")
    end
  end

  # Manual version management
  lane :set_version do |options|
    version = options[:version] || prompt(text: "Enter version (e.g., 1.2.3):")
    build = options[:build] || prompt(text: "Enter build number (e.g., 123):")
    
    increment_version_number(
      version_number: version,
      xcodeproj: "TestCICD.xcodeproj"
    )
    
    increment_build_number(
      build_number: build,
      xcodeproj: "TestCICD.xcodeproj"
    )
    
    UI.success("âœ… Manually set iOS version:")
    UI.success("   CFBundleShortVersionString: #{version}")
    UI.success("   CFBundleVersion: #{build}")
  end

  lane :bump_version do |options|
    type = options[:type] || "patch"
    current_version = get_version_number(xcodeproj: "TestCICD.xcodeproj")
    current_build = get_build_number(xcodeproj: "TestCICD.xcodeproj").to_i
    
    version_parts = current_version.split('.').map(&:to_i)
    
    case type
    when "major"
      version_parts[0] += 1
      version_parts[1] = 0
      version_parts[2] = 0
    when "minor"
      version_parts[1] += 1
      version_parts[2] = 0
    when "patch"
      version_parts[2] += 1
    end
    
    new_version = version_parts.join('.')
    new_build = current_build + 1
    
    increment_version_number(
      version_number: new_version,
      xcodeproj: "TestCICD.xcodeproj"
    )
    
    increment_build_number(
      build_number: new_build.to_s,
      xcodeproj: "TestCICD.xcodeproj"
    )
    
    UI.success("âœ… Bumped #{type} version:")
    UI.success("   #{current_version} -> #{new_version}")
    UI.success("   build: #{current_build} -> #{new_build}")
  end

  # ğŸ”§ à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡: Deployment lanes with better error handling
  lane :deploy_develop do
    UI.message("ğŸš€ Deploying to TestFlight Internal...")
    build_and_deploy(
      groups: ["Internal Testers", "Developers"],
      skip_waiting: true
    )
  end

  lane :deploy_preprod do
    UI.message("ğŸš€ Deploying to TestFlight Beta...")
    build_and_deploy(
      groups: ["Beta Testers", "QA Team"],
      skip_waiting: false
    )
  end

  lane :deploy_master do
    UI.message("ğŸ‰ Deploying to App Store...")
    setup_certificates
    build_release_app
    
    # ğŸ”§ à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡: Better API key handling
    upload_options = build_upload_options(
      submit_for_review: false,
      skip_metadata: true,
      skip_screenshots: true
    )
    
    upload_to_app_store(upload_options)
  end

  lane :build_only do
    UI.message("ğŸ”¨ Building iOS app...")
    setup_certificates
    build_release_app
    UI.success("âœ… iOS build completed successfully!")
  end

  lane :submit_for_review do
    UI.message("ğŸ“‹ Submitting for App Store review...")
    
    upload_options = build_upload_options(
      skip_binary_upload: true,
      submit_for_review: true,
      submission_information: submission_info
    )
    
    upload_to_app_store(upload_options)
  end

  # ğŸ”§ à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡: Enhanced certificate setup with better error handling
  private_lane :setup_certificates do
    UI.message("ğŸ” Setting up certificates...")
    
    api_key_path = ENV['APP_STORE_CONNECT_API_KEY_PATH']
    
    # Validate API key before proceeding
    if api_key_path && validate_api_key(api_key_path)
      UI.message("âœ… Using API key: #{api_key_path}")
      
      match(
        type: "appstore",
        readonly: true,
        api_key_path: api_key_path
      )
    else
      UI.message("âš ï¸ API key validation failed, using traditional auth")
      
      # Fallback to traditional authentication
      match(
        type: "appstore",
        readonly: true
      )
    end
    
    UI.success("âœ… Certificates setup completed")
  end

  # ğŸ†• à¹€à¸à¸´à¹ˆà¸¡: API key validation function
  private_lane :validate_api_key do |api_key_path|
    begin
      unless api_key_path && !api_key_path.empty?
        UI.error("âŒ API key path is empty")
        return false
      end
      
      unless File.exist?(api_key_path)
        UI.error("âŒ API key file not found at: #{api_key_path}")
        return false
      end
      
      file_content = File.read(api_key_path)
      
      # Check file size
      if file_content.length < 100
        UI.error("âŒ API key file too small (#{file_content.length} bytes)")
        return false
      end
      
      # Check format
      unless file_content.start_with?("-----BEGIN PRIVATE KEY-----")
        UI.error("âŒ Invalid API key format")
        UI.error("Expected: -----BEGIN PRIVATE KEY-----")
        UI.error("Found: #{file_content[0..30]}...")
        return false
      end
      
      unless file_content.include?("-----END PRIVATE KEY-----")
        UI.error("âŒ API key file incomplete - missing end marker")
        return false
      end
      
      # Validate required environment variables
      api_key_id = ENV['APP_STORE_CONNECT_API_KEY_ID']
      issuer_id = ENV['APP_STORE_CONNECT_API_ISSUER_ID']
      
      if api_key_id.nil? || api_key_id.empty?
        UI.error("âŒ APP_STORE_CONNECT_API_KEY_ID is missing")
        return false
      end
      
      if issuer_id.nil? || issuer_id.empty?
        UI.error("âŒ APP_STORE_CONNECT_API_ISSUER_ID is missing")
        return false
      end
      
      UI.success("âœ… API key validation passed")
      UI.message("   ğŸ“‹ Key ID: #{api_key_id}")
      UI.message("   ğŸ“‹ Issuer ID: #{issuer_id}")
      UI.message("   ğŸ“„ File size: #{file_content.length} bytes")
      
      return true
      
    rescue => e
      UI.error("âŒ API key validation error: #{e.message}")
      return false
    end
  end

  # ğŸ†• à¹€à¸à¸´à¹ˆà¸¡: Build upload options with API key handling
  private_lane :build_upload_options do |base_options = {}|
    options = {
      force: true,
      automatic_release: false,
      precheck_include_in_app_purchases: false
    }.merge(base_options)
    
    # Add API key if available and valid
    api_key_path = ENV['APP_STORE_CONNECT_API_KEY_PATH']
    if api_key_path && validate_api_key(api_key_path)
      options[:api_key_path] = api_key_path
      UI.message("âœ… Using API key authentication")
    else
      UI.message("âš ï¸ Using traditional authentication (username/password)")
    end
    
    return options
  end

  private_lane :build_release_app do
    build_app(
      scheme: "TestCICD",
      workspace: "TestCICD.xcworkspace",
      configuration: "Release",
      export_method: "app-store",
      clean: true,
      output_directory: "./build",
      output_name: "TestCICD.ipa",
      include_bitcode: false,
      export_options: {
        provisioningProfiles: {
          "test.cicd.appibc" => "match AppStore test.cicd.appibc"
        }
      }
    )
  end

  # ğŸ”§ à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡: Enhanced build_and_deploy with better error handling
  private_lane :build_and_deploy do |options|
    setup_certificates
    build_release_app
    
    upload_options = {
      skip_waiting_for_build_processing: options[:skip_waiting],
      groups: options[:groups],
      distribute_external: false,
      notify_external_testers: false,
      changelog: "Automated build from #{ENV['GITHUB_REF_NAME']} branch"
    }
    
    # Add API key if available and valid
    api_key_path = ENV['APP_STORE_CONNECT_API_KEY_PATH']
    if api_key_path && validate_api_key(api_key_path)
      upload_options[:api_key_path] = api_key_path
      UI.message("âœ… Using API key for TestFlight upload")
    else
      UI.message("âš ï¸ Using traditional authentication for TestFlight upload")
    end
    
    upload_to_testflight(upload_options)
  end

  private_lane :submission_info do
    {
      add_id_info_limits_tracking: true,
      add_id_info_serves_ads: false,
      add_id_info_tracks_action: true,
      add_id_info_tracks_install: true,
      add_id_info_uses_idfa: true,
      content_rights_has_rights: true,
      content_rights_contains_third_party_content: true,
      export_compliance_platform: 'ios',
      export_compliance_compliance_required: false,
      export_compliance_encryption_updated: false,
      export_compliance_uses_encryption: false,
      export_compliance_is_exempt: false,
      export_compliance_contains_third_party_cryptography: false,
      export_compliance_contains_proprietary_cryptography: false,
      export_compliance_available_on_french_store: false
    }
  end

  private_lane :notify_slack do |message|
    return unless ENV["SLACK_URL"]
    
    begin
      slack(
        message: message,
        channel: "#releases",
        webhook_url: ENV["SLACK_URL"],
        username: "iOS CI/CD",
        icon_emoji: ":apple:"
      )
    rescue => e
      UI.error("Failed to send Slack notification: #{e.message}")
    end
  end

  # Enhanced error handling
  error do |lane, exception|
    error_message = "âŒ iOS deployment failed in lane '#{lane}': #{exception.message}"
    UI.error(error_message)
    UI.error("Stack trace: #{exception.backtrace.join("\n")}")
    
    # Additional debugging info
    if lane.to_s.include?('deploy') || lane.to_s.include?('upload')
      UI.error("ğŸ” Debugging information:")
      UI.error("   API Key Path: #{ENV['APP_STORE_CONNECT_API_KEY_PATH']}")
      UI.error("   API Key ID: #{ENV['APP_STORE_CONNECT_API_KEY_ID']}")
      UI.error("   Issuer ID: #{ENV['APP_STORE_CONNECT_API_ISSUER_ID']}")
      
      api_key_path = ENV['APP_STORE_CONNECT_API_KEY_PATH']
      if api_key_path && File.exist?(api_key_path)
        file_size = File.size(api_key_path)
        UI.error("   API Key file exists: #{file_size} bytes")
        
        # Show first few characters for debugging (safely)
        content_preview = File.read(api_key_path, 50)
        UI.error("   File starts with: #{content_preview}")
      else
        UI.error("   API Key file: NOT FOUND")
      end
    end
    
    raise exception
  end
end